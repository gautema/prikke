<.docs_layout current_scope={@current_scope}>
  <h1>Webhooks</h1>
  <p class="text-xl text-slate-600 mb-10">
    How we call your endpoints, handle failures, and keep things reliable.
  </p>

  <h2>How It Works</h2>
  <p>
    When a task triggers, Runlater makes an HTTP request to your configured URL. Your endpoint processes the request and returns a response.
  </p>
  <ol>
    <li>Task triggers (cron schedule or one-time)</li>
    <li>Runlater sends HTTP request to your URL</li>
    <li>Your server processes the request</li>
    <li>Return 2xx status for success</li>
    <li>We log the result and schedule retries if needed</li>
  </ol>

  <h2>Request Format</h2>
  <p>Every webhook request includes these headers:</p>
  <pre
    phx-no-curly-interpolation
    class="bg-slate-900 text-slate-100 p-5 rounded-lg text-sm font-mono leading-relaxed overflow-x-auto"
  ><span class="text-purple-300">POST</span> /your-endpoint HTTP/1.1
<span class="text-sky-300">Host</span>: your-app.com
<span class="text-sky-300">Content-Type</span>: application/json
<span class="text-sky-300">X-Runlater-Task-Id</span>: 01JJXYZ...
<span class="text-sky-300">X-Runlater-Execution-Id</span>: 01JJXYZ...
<span class="text-sky-300">X-Runlater-Signature</span>: sha256=a1b2c3d4...
<span class="text-sky-300">Authorization</span>: Bearer your-token  <span class="text-slate-500">(if configured)</span>

<span class="text-slate-500">// Your configured body (if any)</span>
{"action": "sync"}</pre>

  <div class="overflow-x-auto my-6">
    <table class="w-full text-sm">
      <thead>
        <tr class="border-b border-white/50">
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Header</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Description</th>
        </tr>
      </thead>
      <tbody class="text-slate-600">
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4"><code class="text-sky-600">X-Runlater-Task-Id</code></td>
          <td class="py-3 px-4">The ID of the task being executed</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4"><code class="text-sky-600">X-Runlater-Execution-Id</code></td>
          <td class="py-3 px-4">Unique ID for this execution (use for deduplication)</td>
        </tr>
        <tr>
          <td class="py-3 px-4"><code class="text-sky-600">X-Runlater-Signature</code></td>
          <td class="py-3 px-4">HMAC-SHA256 signature of the request body</td>
        </tr>
      </tbody>
    </table>
  </div>

  <h2>Verifying Signatures</h2>
  <p>
    Every request is signed with your organization's webhook secret. Verify the signature to ensure requests are from Runlater.
  </p>
  <p class="text-sm text-slate-500 mb-4">
    Find your webhook secret in <a
      href="/organizations/api-keys"
      class="text-emerald-600 hover:underline"
    >Organization Settings → API Keys</a>.
  </p>

  <div class="glass-card rounded-2xl overflow-hidden my-6">
    <div class="px-5 py-3 text-xs text-slate-400 bg-slate-800 border-b border-slate-700">
      Node.js
    </div>
    <pre
      phx-no-curly-interpolation
      class="m-0 bg-slate-900 text-slate-100 p-5 text-sm font-mono leading-relaxed overflow-x-auto"
    ><span class="text-purple-300">const</span> crypto = <span class="text-purple-300">require</span>(<span class="text-green-300">'crypto'</span>);

<span class="text-purple-300">function</span> <span class="text-sky-300">verifySignature</span>(body, signature, secret) {
  <span class="text-purple-300">const</span> expected = crypto
    .createHmac(<span class="text-green-300">'sha256'</span>, secret)
    .update(body)
    .digest(<span class="text-green-300">'hex'</span>);

  <span class="text-purple-300">return</span> <span class="text-green-300">`sha256=${expected}`</span> === signature;
}

app.post(<span class="text-green-300">'/webhook'</span>, (req, res) =&gt; {
  <span class="text-purple-300">const</span> signature = req.headers[<span class="text-green-300">'x-runlater-signature'</span>];
  <span class="text-purple-300">const</span> body = JSON.stringify(req.body); <span class="text-slate-500">// or raw body buffer</span>

  <span class="text-purple-300">if</span> (!verifySignature(body, signature, process.env.RUNLATER_WEBHOOK_SECRET)) {
    <span class="text-purple-300">return</span> res.status(<span class="text-orange-300">401</span>).json({ <span class="text-sky-300">error</span>: <span class="text-green-300">'Invalid signature'</span> });
  }

  <span class="text-slate-500">// Safe to process - request is from Runlater</span>
  <span class="text-purple-300">const</span> taskId = req.headers[<span class="text-green-300">'x-runlater-task-id'</span>];
  <span class="text-purple-300">const</span> executionId = req.headers[<span class="text-green-300">'x-runlater-execution-id'</span>];

  <span class="text-slate-500">// Process the task...</span>
  res.json({ <span class="text-sky-300">ok</span>: <span class="text-orange-300">true</span> });
});</pre>
  </div>

  <h2>Response Handling</h2>
  <p>Runlater interprets your response status code:</p>
  <div class="overflow-x-auto my-6">
    <table class="w-full text-sm">
      <thead>
        <tr class="border-b border-white/50">
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Status</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Result</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Action</th>
        </tr>
      </thead>
      <tbody class="text-slate-600">
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4"><code class="text-emerald-600">2xx</code></td>
          <td class="py-3 px-4">Success</td>
          <td class="py-3 px-4">Task marked complete</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4"><code class="text-amber-600">4xx</code></td>
          <td class="py-3 px-4">Client error</td>
          <td class="py-3 px-4">Task marked failed (no retry)</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4"><code class="text-red-600">5xx</code></td>
          <td class="py-3 px-4">Server error</td>
          <td class="py-3 px-4">Task retried with backoff</td>
        </tr>
        <tr>
          <td class="py-3 px-4"><code class="text-slate-500">Timeout</code></td>
          <td class="py-3 px-4">Timeout</td>
          <td class="py-3 px-4">Task retried with backoff</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="bg-emerald-50 border-l-4 border-emerald-600 p-4 rounded-r-lg my-6">
    <strong class="text-emerald-800">Tip:</strong>
    <span class="text-emerald-700">
      Return 4xx for permanent failures (bad data, validation errors) and 5xx for temporary failures (database down, external service unavailable).
    </span>
  </div>

  <h2>Timeouts</h2>
  <p>
    Your endpoint has <strong>30 seconds</strong>
    to respond. If no response is received within this time, the execution is marked as a timeout and scheduled for retry.
  </p>

  <div class="bg-amber-50 border-l-4 border-amber-500 p-4 rounded-r-lg my-6">
    <strong class="text-amber-800">Long-running tasks:</strong>
    <span class="text-amber-700">
      If your task takes longer than 30 seconds, acknowledge the request immediately and process asynchronously. Return 200 to indicate the task was accepted.
    </span>
  </div>

  <h2>Automatic Retries</h2>
  <p>Retry behavior depends on the task type:</p>

  <h3>One-time Tasks (run_at)</h3>
  <p>One-time tasks automatically retry with exponential backoff:</p>
  <div class="overflow-x-auto my-6">
    <table class="w-full text-sm">
      <thead>
        <tr class="border-b border-white/50">
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Attempt</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Delay</th>
        </tr>
      </thead>
      <tbody class="text-slate-600">
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">1st retry</td>
          <td class="py-3 px-4">20 seconds</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">2nd retry</td>
          <td class="py-3 px-4">45 seconds</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">3rd retry</td>
          <td class="py-3 px-4">~1.5 minutes</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">4th retry</td>
          <td class="py-3 px-4">~2 minutes</td>
        </tr>
        <tr>
          <td class="py-3 px-4">5th retry</td>
          <td class="py-3 px-4">~3 minutes</td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>
    After 5 failed attempts, the task is marked as permanently failed and you'll receive an alert (if configured).
  </p>

  <h3>Recurring Tasks (cron)</h3>
  <p>
    Cron tasks do <strong>not</strong>
    retry. If a scheduled run fails, the next scheduled run will execute as normal. This prevents retry storms and duplicate executions.
  </p>

  <div class="bg-emerald-50 border-l-4 border-emerald-600 p-4 rounded-r-lg my-6">
    <strong class="text-emerald-800">Why no retries for cron?</strong>
    <span class="text-emerald-700">
      A minute-interval cron with 5 retries would create chaos - by the time retries finish, hundreds of scheduled runs would have stacked up. The next scheduled run is effectively your retry.
    </span>
  </div>

  <h2>Idempotency</h2>
  <p>
    Your webhook handler should be <strong>idempotent</strong>
    - safe to call multiple times with the same data. This is important because:
  </p>
  <ul>
    <li>Network issues may cause duplicate deliveries</li>
    <li>Retries will re-send the same request</li>
    <li>A timeout might occur after your server processed the request</li>
  </ul>

  <p>
    Use the <code class="bg-slate-100 px-2 py-1 rounded text-sm">X-Runlater-Execution-Id</code>
    header to deduplicate:
  </p>
  <div class="glass-card rounded-2xl overflow-hidden my-6">
    <div class="px-5 py-3 text-xs text-slate-400 bg-slate-800 border-b border-slate-700">
      Deduplication Example
    </div>
    <pre
      phx-no-curly-interpolation
      class="m-0 bg-slate-900 text-slate-100 p-5 text-sm font-mono leading-relaxed overflow-x-auto"
    ><span class="text-slate-500">// Track processed executions</span>
<span class="text-purple-300">const</span> processed = <span class="text-purple-300">new</span> Set(); <span class="text-slate-500">// Use Redis in production</span>

app.post(<span class="text-green-300">'/webhook'</span>, <span class="text-purple-300">async</span> (req, res) =&gt; {
  <span class="text-purple-300">const</span> executionId = req.headers[<span class="text-green-300">'x-runlater-execution-id'</span>];

  <span class="text-purple-300">if</span> (processed.has(executionId)) {
    <span class="text-purple-300">return</span> res.json({ <span class="text-sky-300">status</span>: <span class="text-green-300">'already_processed'</span> });
  }

  <span class="text-slate-500">// Process the task...</span>
  <span class="text-purple-300">await</span> doWork();

  processed.add(executionId);
  res.json({ <span class="text-sky-300">status</span>: <span class="text-green-300">'ok'</span> });
});</pre>
  </div>

  <h2 id="callbacks">Callbacks</h2>
  <p>
    Get notified when an execution completes by setting a
    <code class="bg-slate-100 px-2 py-1 rounded text-sm">callback_url</code>
    on your task. After each execution finishes (success, failure, or timeout), Runlater will POST the result to your callback URL.
  </p>

  <h3>How Callbacks Work</h3>
  <ol>
    <li>
      Set <code class="bg-slate-100 px-2 py-1 rounded text-sm">callback_url</code> on a task
    </li>
    <li>Runlater executes your webhook as normal</li>
    <li>After completion, Runlater POSTs the result to your callback URL</li>
    <li>Callbacks retry up to 3 times with backoff (5s, 20s) on failure</li>
  </ol>

  <h3>Callback Payload</h3>
  <pre
    phx-no-curly-interpolation
    class="bg-slate-900 text-slate-100 p-5 rounded-lg text-sm font-mono leading-relaxed overflow-x-auto"
  ><span class="text-purple-300">POST</span> /your-callback HTTP/1.1
<span class="text-sky-300">Content-Type</span>: application/json
<span class="text-sky-300">X-Runlater-Signature</span>: sha256=a1b2c3d4...

{
  <span class="text-sky-300">"event"</span>: <span class="text-green-300">"execution.completed"</span>,
  <span class="text-sky-300">"task_id"</span>: <span class="text-green-300">"01JJXYZ..."</span>,
  <span class="text-sky-300">"execution_id"</span>: <span class="text-green-300">"01JJXYZ..."</span>,
  <span class="text-sky-300">"status"</span>: <span class="text-green-300">"success"</span>,
  <span class="text-sky-300">"status_code"</span>: <span class="text-orange-300">200</span>,
  <span class="text-sky-300">"duration_ms"</span>: <span class="text-orange-300">145</span>,
  <span class="text-sky-300">"started_at"</span>: <span class="text-green-300">"2025-01-29T10:00:01Z"</span>,
  <span class="text-sky-300">"finished_at"</span>: <span class="text-green-300">"2025-01-29T10:00:01Z"</span>,
  <span class="text-sky-300">"attempt"</span>: <span class="text-orange-300">1</span>
}</pre>

  <h3>Callback Priority</h3>
  <p>
    Callbacks can be set at two levels. The execution-level callback (from a queue push) takes priority over the task-level callback:
  </p>
  <div class="overflow-x-auto my-6">
    <table class="w-full text-sm">
      <thead>
        <tr class="border-b border-white/50">
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Task callback_url</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Queue callback_url</th>
          <th class="text-left py-3 px-4 font-semibold text-slate-700">Result</th>
        </tr>
      </thead>
      <tbody class="text-slate-600">
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">Set</td>
          <td class="py-3 px-4">Not set</td>
          <td class="py-3 px-4">Uses task callback_url</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">Set</td>
          <td class="py-3 px-4">Set</td>
          <td class="py-3 px-4">Uses queue callback_url (override)</td>
        </tr>
        <tr class="border-b border-slate-100">
          <td class="py-3 px-4">Not set</td>
          <td class="py-3 px-4">Set</td>
          <td class="py-3 px-4">Uses queue callback_url</td>
        </tr>
        <tr>
          <td class="py-3 px-4">Not set</td>
          <td class="py-3 px-4">Not set</td>
          <td class="py-3 px-4">No callback</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="bg-emerald-50 border-l-4 border-emerald-600 p-4 rounded-r-lg my-6">
    <strong class="text-emerald-800">Note:</strong>
    <span class="text-emerald-700">
      Callbacks are signed with the same webhook secret as regular webhook requests. Verify the
      <code>X-Runlater-Signature</code>
      header to authenticate callbacks.
    </span>
  </div>

  <h2 id="notifications">Notifications</h2>
  <p>
    Runlater can notify you via email and webhook when task execution status changes. Configure these in <a
      href="/organizations/notifications"
      class="text-emerald-600 hover:underline"
    >Organization Settings → Notifications</a>.
  </p>

  <h3>Failure Notifications</h3>
  <p>
    Triggered on the <strong>first failure</strong>
    in a sequence (not on every consecutive failure). If a task fails 5 times in a row, you only get one notification.
  </p>

  <h3>Recovery Notifications</h3>
  <p>
    Triggered when a task <strong>succeeds after a failure</strong>. This lets you know your service is back to normal without manually checking the dashboard.
  </p>

  <p>
    Both notification types are sent to your configured email and webhook URL. Webhook payloads are auto-formatted for Slack and Discord.
  </p>

  <h3>Notification Webhook Payloads</h3>
  <pre
    phx-no-curly-interpolation
    class="bg-slate-900 text-slate-100 p-5 rounded-lg text-sm font-mono leading-relaxed overflow-x-auto"
  ><span class="text-slate-500">// Failure notification</span>
{
  <span class="text-sky-300">"event"</span>: <span class="text-green-300">"task.failed"</span>,
  <span class="text-sky-300">"task"</span>: { <span class="text-sky-300">"id"</span>: <span class="text-green-300">"..."</span>, <span class="text-sky-300">"name"</span>: <span class="text-green-300">"..."</span>, <span class="text-sky-300">"url"</span>: <span class="text-green-300">"..."</span> },
  <span class="text-sky-300">"execution"</span>: { <span class="text-sky-300">"status"</span>: <span class="text-green-300">"failed"</span>, <span class="text-sky-300">"status_code"</span>: <span class="text-orange-300">500</span>, ... }
}

<span class="text-slate-500">// Recovery notification</span>
{
  <span class="text-sky-300">"event"</span>: <span class="text-green-300">"task.recovered"</span>,
  <span class="text-sky-300">"task"</span>: { <span class="text-sky-300">"id"</span>: <span class="text-green-300">"..."</span>, <span class="text-sky-300">"name"</span>: <span class="text-green-300">"..."</span>, <span class="text-sky-300">"url"</span>: <span class="text-green-300">"..."</span> },
  <span class="text-sky-300">"execution"</span>: { <span class="text-sky-300">"status"</span>: <span class="text-green-300">"success"</span>, <span class="text-sky-300">"status_code"</span>: <span class="text-orange-300">200</span>, ... }
}</pre>

  <h2>Custom Headers</h2>
  <p>You can configure custom headers when creating a task:</p>
  <div class="glass-card rounded-2xl overflow-hidden my-6">
    <div data-tab-group>
      <div class="flex border-b border-slate-700">
        <button data-tab="curl" class="px-4 py-2 text-xs font-medium border-b-2 text-emerald-400 border-emerald-400 cursor-pointer">curl</button>
        <button data-tab="js" class="px-4 py-2 text-xs font-medium border-b-2 text-slate-500 border-transparent cursor-pointer">Node.js</button>
      </div>
      <pre
        data-tab-content="curl"
        phx-no-curly-interpolation
        class="m-0 bg-slate-900 text-slate-100 p-5 text-sm font-mono leading-relaxed overflow-x-auto"
      >curl -X POST https://runlater.eu/api/v1/tasks \
  -H <span class="text-green-300">"Authorization: Bearer pk_live_xxx"</span> \
  -H <span class="text-green-300">"Content-Type: application/json"</span> \
  -d '{
    <span class="text-sky-300">"name"</span>: <span class="text-green-300">"My task"</span>,
    <span class="text-sky-300">"url"</span>: <span class="text-green-300">"https://myapp.com/webhook"</span>,
    <span class="text-sky-300">"schedule_type"</span>: <span class="text-green-300">"cron"</span>,
    <span class="text-sky-300">"cron_expression"</span>: <span class="text-green-300">"0 * * * *"</span>,
    <span class="text-sky-300">"headers"</span>: {
      <span class="text-sky-300">"Authorization"</span>: <span class="text-green-300">"Bearer my-app-token"</span>,
      <span class="text-sky-300">"X-Custom-Header"</span>: <span class="text-green-300">"custom-value"</span>
    }
  }'</pre>
      <pre
        data-tab-content="js"
        style="display:none"
        phx-no-curly-interpolation
        class="m-0 bg-slate-900 text-slate-100 p-5 text-sm font-mono leading-relaxed overflow-x-auto"
      ><span class="text-purple-300">await</span> rl.<span class="text-sky-300">cron</span>(<span class="text-green-300">"my-task"</span>, {
  <span class="text-sky-300">url</span>: <span class="text-green-300">"https://myapp.com/webhook"</span>,
  <span class="text-sky-300">schedule</span>: <span class="text-green-300">"0 * * * *"</span>,
  <span class="text-sky-300">headers</span>: {
    <span class="text-green-300">"Authorization"</span>: <span class="text-green-300">"Bearer my-app-token"</span>,
    <span class="text-green-300">"X-Custom-Header"</span>: <span class="text-green-300">"custom-value"</span>
  }
})</pre>
    </div>
  </div>
</.docs_layout>
